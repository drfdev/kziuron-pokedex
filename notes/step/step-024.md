#### Шаг 24

В данном шаге будем делать клонер  
Сначала, представим как он должен работать: объект типа А подается на вход,
и в результате должен быть получен так же объект типа А. Причем: исходный объект и результат
должны совпадать по всем полям, но не совпадать по `==`

Для этого мы будем генерировать исходный код класса исходя из текущей модели  
У нас есть плагин, который это будет делать: считает все классы, и для каждого класс напишет свой
метод клонирования

Я думал, как будет сделать правильно.  
Вариант первый: сделать один метод клонирования, вида:
```java
public static <T extends IdentifiableEntity> T clone(T entity);
```
Но понял что внутри него придется или делать очень много `if-else` (что некрасиво и плохо по производительности)
Или делать `map` (что хорошо по производительности, но занимает память)

Второй вариант: сделать на каждую сущность по своему отдельному методу  
Мне кажется такой вариант наиболее удобным: относительно быстро и без лишних структур в памяти,
но не очень эстетично (не люблю перегрузку операторов)

---

В настройки плагина нужно добавить следующие параметры:
* mainInterface - интерфейс от которого все другие классы модели должны быть унаследованы
* cloneName - имя результирующего класса

Параметр `mainInterface` нужен чтобы не поймать лишние классы в процессе генерации,
чтобы сделать работу только для классов модели

Для обновления данных, я проверил модель. Все сущности состоят или из других сущностей, или из стандартных классов.
Для примитивных типов подойдет копирование, а для базовых классов, таких как `String` или `Instant`
ничего дополнительно делать не нужно

В теории можно добавить такой код: `return new String(originalStr);`, но это не эффективно.
Стандартные классы (строки, числа, `java.time`) это неизменяемые классы, поэтому делать копию константы глупо.
Особенно для строк, из-за их пула строк и для чисел, из-за их кеширования.

---

Главная проблема результирующей утилиты - это ее непотокобезопасность  
Т.к. я собираюсь копировать объекты по полям, а это не атомарная операция, то во время копирования
объект можно легко "сломать" (обновив его данные), и тем самым испортив клона.  
Механизм отслеживания изменений не плохо было бы добавить внутрь самой модели, но это достаточно сложно.
Механизм атомарного клонирования тоже достаточно не просто сделать.
Поэтому я решил что не буду с этим делать ничего, и просто помечу результирующий класс аннотацией
`javax.annotation.concurrent.NotThreadSafe`

---

Я долго думал что использовать для чтения джава классов  
Проблема возникла следующая: когда запускается плагин у нас есть исходники классов, но на фазе генерации ресурсов
нет скомпилированных классов. Из-за этого нельзя загрузить классы в рантайме из класслоадера, и значит никакой
рефлексии. Но у меня есть исходники классов. Их можно загрузить в класслоуадер из текстовых файлов, но там нужно
загружать в правильном порядке, и просто так не придумать как это красиво сделать  

В общем, я нашел библиотеку: `com.github.javaparser`, которая читает текстовые классы и парсит в объекты.  
Можно загрузить класс, получить список полей и уже дальше с этим аккуратно работать.


---

Генерация класс сделана через библиотеку javapoet  
Для понимания работы стоит почитать документацию, или комментарии в классе `ClassGenerator`


---

Результат работы будет записан в класс:  
`kziuron-pokedex/kziuron-pokedex-model/target/generated-sources/model-processor/dev/drf/pokedex/model/PokedexClonerUtils.java`

На этапе генерации думаю стоит этот шаг завершить  
В следующем шаге нужно будет заставить этот класс компилироваться и добавить тесты на его работу
(ну и если будут ошибки, внести правки в генератор)


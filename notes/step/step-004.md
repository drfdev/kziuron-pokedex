#### Шаг 4

Планировалось что в приложении будет 3 модуля: UI, Business и Core
Каждый модуль представляет отдельный кусок приложения, который выполняет свои функции
Но каким-то образом должно осуществляться общение между модулями

Для этого у каждого модуля будет свое API
Модуль будет представлять собой черный ящик, который просто как-то работает, но его функционал нам неизвестен и что происходит внутри тоже.
Доступ к функциям модуля можно будет получить только через API - интерфейсы доступные снаружи.

Схема взаимодействия:
[**ui module**] <--> businessApi -> [**business module**] <--> coreApi -> [**core module**]

Для описания API сделаем отдельный модуль, в котором будут лежать интерфейсы.
Я долго думал как сделать правильнее: хранить описания API отдельно или API модуля внутри модуля.
Вроде бы и так и так можно сделать, но решил вынести все отдельно для наглядности

Добавим аннотацию `@Api` чтобы отмечать ей классы API: ей можно пометить только классы, и она будет доступна в рантайме
Добавим `enum` для описания статуса - успех (SUCCESS) или неудача (ERROR)
Добавим класс контейнер результата выполнения API: `ApiResult`: в нем будет статус, результат (указанный как дженерик) и описание ошибки (код и сообщение)

Добавим зависимость на `findbugs`, чтобы иметь доступ к аннотациям `@Nonnull` и `@Nullable`
Будем отмечать ими параметры и методы, которые могут быть null или не могут быть null
Стороннюю зависимость вынесем в родительским pom, в раздел `dependencyManagement`

update: в 16 версии java добавилось ключевое слово record, поэтому классы ApiError и ApiResult могут быть обозначены как record

В core-api у нас будет два типа API: синхронное и асинхронное:
основные API - синхронные
API для фоновых операций асинхронное: содержит интерфейс для вызова, но вызов происходит не сразу, а через какое-то время
Результат вызова можно получить в колбек, или подождать ответа какое-то время (см. класс `AsyncResult`)